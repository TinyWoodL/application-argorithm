# 数组、链表、哈希

## 前言

    1、了解数组、链表的基础内容
    2、在知道了底层的数据存储结构之后，再来看看哈希的简单实现原理
    3、作为扩展、了解一致性哈希

必要的知识：大 O 表示法和对数

#### 复习下复杂度概念

`选择排序`：
```
def colloction_sort(arr):
    newArr = []
    for i in range(len(arr)):
        smallest = find_smallest(arr)
        newArr.append(arr.pop(smallest))

    return newArr

def find_smallest(arr):
    smallest = arr[0]
    smallest_index = 0
    for i in range(1, len(arr)):
        if arr[i] < smallest:
            smallest = arr[i]
            smallest_index = i

    return smallest_index

arr = [1, 2, 5, 7, 11, 4, 5, 5, 19]
arr = colloction_sort(arr)

print(arr)
```

## 了解内存的工作原理

假设我们要使用寄存柜存放我们的物品：

    1、要两个柜子存我们的物品
    2、将物品放入各自的柜子
    3、我们只要记住柜子的编号（地址）

计算机内存就是很多抽屉的集合，每个抽屉都有自己的地址。需要存储数据时，请求计算机提供存储空间，计算机将返回一个存储地址。

`需要存储多项数据时`，有两种基本方式：数组和链表

<img src="">

## 数组

数组是一种`线性表`数据结构，**用一组连续的内存空间来存储一组具有相同类型结构的数据**，有两个特点：

- 线性表：数据结构排列成一条线一样。数据只有向前或者向后
- 连续的内存空间：数据在存储的时候占用的是一段连续的内存空间。

> 这里的线性数据结构，不是指内存中存储数据按线性顺序往下存，而是数据的组织形式是线性的，只能往前或者往后。

### 数组中数据的存储和访问

我们在代码中实现数组：
```
#include <stdio.h>

int main(int argc, char const *argv[])
{
    int arr[10];
    for (int i = 0; i < 10; i++)
    {
        arr[i] = i;
    }

    printf("%d\n",arr[1]);
    printf("%d\n",arr[10]);
}
```

1、计算机给 arr 分配了一段连续的内存空间。

2、内存空间的首地址 base_address

则 arr 数组的寻址公式为 a[i]_address = base_address + i * data_type_size;


**所以数组支持随机访问，且复杂度为 O(1)**

### 插入

在长度为 n 的数组中，如果我们要在 k 位置插入一个元素，我们需要将 k ~ n 个元素都往后移动一位， 此时复杂度为 O(n)。

> 当然在不连续数组中，可以优化为第 k 个元素移动到末尾，再插入数据。此时复杂度降低为 O(1)。

### 删除

一般情况下和插入的复杂度类似

> 当我们不追求数据的连续性的时候，可以仅仅记录数据被删除而不执行数据的删除操作，当没有足够的存储空间的时候在将标记的数据统一删除。 这也是 JVM 标记清除垃圾回收算法的核心思想。

### 越界的问题

在 C 语言中除了访问受限制的内存，其他内存都是可以访问的。所以根据前面的寻址公式，a[10] 会被定位到不属于数组的内存空间。

### 容器是否可以替代数组

* 容器对数组的很多细节进行了封装，支持动态扩容。

* 数组不够灵活。（如只能存储相同的类型等）

* 容器牺牲了一些性能

## 链表

链表是一种`线性`数据结构。但是他有特殊的底层结构：

- 链表不需要连续的内存空间，它通过指针将一组零散的内存块串联起来使用。
- 结点：指被串联的内存块，第一个结点被称为头结点，最后一个结点被称为尾结点
- 后继指针：记录下一个结点地址的指针

### 链表中数据的存储和访问

### 插入

链表的插入和删除只要改变指针的指向就可以了，复杂度为 O(1)

### 删除

因为链表不是连续内存空间存储的，所以无法通过寻址公式计算出内存位置，只能通过个个结点的遍历直到找到目标， 复杂度为 O(n)

### 特殊的链表

`循环链表`：即尾结点的后继指针指向头结点，适用于处理环形结构特点的数据。如 约瑟夫问题

`双向链表`: 即除了后继指针外，还有一个前驱指针

## 哈希

从商品的价目表说起：

    在杂货店中，有按字母顺序排列的商品价目表。

        | apple  | 1$
        | banana | 2$
        | egg    | 2$

此时我们可以比较简单查找和前面将的二分查找之间的区别：假设 1 秒可以看 10 行

        | 商品数量 | O(n)  | O(log n) |
        | 100     |  10s  |  1s      |  log 100 = 7
        | 1000    |  100s |  1s      |  log 1000 = 10
        | 10000   |  16.6m|  2s      |  log 10000 = 14 行

利用二分查找的速度已经非常快了。 但是，作为一个收银员，每次都要去查找是一个很痛苦的事情，所以我们需要的是能够记住所有商品价格，能够立马得到结果的机制。

        |  O(1) |
        |  立即  |
        |  立即  |
        |  立即  |

该如何实现呢？可以利用前面介绍的两个数据结构，实现散列表。

### 原理介绍

首先我们要有一个`散列函数`: 无论输入的是什么东西，都能得到一个数字。

- 对于相同的输入，得到的数字结果不变。
- 对于不同的输入，得到的数字结果不同（冲突的问题）

所以我们可以对所有的商品名称进行散列函数过滤得到不同的数字，将其作为下标，价格填入到数组当中去。
```
apple  =>  3
banana =>  4

a[], [], [], [3] = 1, [4] = 2
```

这样我们就得到了一个`散列表`。

`散列表`是包含额外逻辑的数据结构，通过额外的散列函数来确定元素存储的位置。特点：key => value

### 应用案例

    1、手机电话簿的号码查找
    2、去重
    3、用做缓存

### 额外扩展

#### （冲突）
散列函数的冲突问题：不同的输入得到同样的输出

简单的解决方法：在同一个位置存储一个链表

#### 填装因子

#### 良好的散列函数

### 性能分析

复杂度。

## 实例：一致性哈希

### 面对的问题

#### Redis 集群

我们为了保证 Redis 的高可用，不仅搭建 Redis 的集群，实现数据的读写分离，对单表数据量过大的情况，还进行分表。

假设一个网站，使用 Redis 存储图片资源，key 为图片名称，value 为图片的实际服务器地址，我们需要根据文件名查找图片所在的服务器，则我们可以进行分表，如下图所示：

<img src="../assets/redis-1.jpg?raw=true">

这时如果用户想获取一张名为 a.png 的图片，由于不确定在哪一台 Redis 服务器上，需要对每个都遍历。这显然是不可取的方法。更好的方式是通过 Hash，将每个资源定位到特定的服务器上，如下图所示：

<img src="../assets/redis-2.jpg?raw=true">

假设有四台服务器，此时通过公式 hash(a,png) % 4 可以定位到第二台服务器，避免了遍历。

#### Hash 的问题

前面的 hash 算法存在缺陷：当服务器的数量变化的时候，所有的缓存位置都要改变。即当增加一台服务器时，公式变成了 hash(a.png) % 5，此时原来的缓存都是失效的，需要对数据重新做缓存。同样当一台服务器失效后，产生的后果也是一样的。

> 当然还有减少服务器的时候，或者某一台服务器宕机的时候

所以提出了一种新的缓存取址方式：一致性哈希

### 一致性哈希简介

一致性哈希对 2^32 取模，即将整个 hash 空间构成一个虚拟的圆环，如下图所示：

<img src="../assets/hash-1.jpg?raw=true">

这样我们对每个缓存服务器使用 hash 进行一个哈希（如使用ip或者主机名），最后所有的服务器都分布在环上。 这样，我们只要使用相同的 hash 算法对数据的 key 进行计算，得到此数据在环上的位置，从此位置沿环顺时针遇到的第一台服务器就是定位的服务器。寻址过程如下图所示：

<img src="../assets/hash-2.jpg?raw=true">

<img src="../assets/hash-3.jpg?raw=true">

根据算法，此时 ObjectA、B、C、D都被指向到了对应的服务器，不必再做遍历寻址


### 其他情况下的处理

当增加或者减少服务器时，会如何处理

当服务器数量较少时，怎么保证均匀分布 （数据倾斜）

### 回过头来看一致性哈希算法的好坏

对于动态变化的 cache 环境，定义了4个判断好坏的指标:

- 平衡性：指哈希的结果要能够尽可能的分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。
- 单调性（Monotonicity）：对新增加的缓冲内容，不会影响原有的缓冲。
- 分散性（Spread）：尽量避免相同的内容被不同的终端映射到不同的缓冲区中
- 负载（load）：对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。这样的情况也要努力避免

## 最关键的：作业

1、写代码实现 一致性哈希 的逻辑

2、完成链表作业