## 数组

数组是一种`线性表`数据结构，**用一组连续的内存空间来存储一组具有相同类型结构的数据**，有两个特点：

- 线性表：数据结构排列成一条线一样。数据只有向前或者向后
- 连续的内存空间：数据在存储的时候占用的是一段连续的内存空间。

> 这里的线性数据结构，不是指内存中存储数据按线性顺序往下存，而是数据的组织形式是线性的，只能往前或者往后。

### 数组中数据的存储和访问

我们在代码中实现数组：
```
#include <stdio.h>

int main(int argc, char const *argv[])
{
    int arr[10];
    for (int i = 0; i < 10; i++)
    {
        arr[i] = i;
    }

    printf("%d\n",arr[1]);
    printf("%d\n",arr[10]);
}
```

1、计算机给 arr 分配了一段连续的内存空间。

2、内存空间的首地址 base_address

则 arr 数组的寻址公式为 a[i]_address = base_address + i * data_type_size;


**所以数组支持随机访问，且复杂度为 O(1)**

### 插入

在长度为 n 的数组中，如果我们要在 k 位置插入一个元素，我们需要将 k ~ n 个元素都往后移动一位， 此时复杂度为 O(n)。

> 当然在不连续数组中，可以优化为第 k 个元素移动到末尾，再插入数据。此时复杂度降低为 O(1)。

### 删除

一般情况下和插入的复杂度类似

> 当我们不追求数据的连续性的时候，可以仅仅记录数据被删除而不执行数据的删除操作，当没有足够的存储空间的时候在将标记的数据统一删除。 这也是 JVM 标记清除垃圾回收算法的核心思想。

### 越界的问题

在 C 语言中除了访问受限制的内存，其他内存都是可以访问的。所以根据前面的寻址公式，a[10] 会被定位到不属于数组的内存空间。

### 容器是否可以替代数组

* 容器对数组的很多细节进行了封装，支持动态扩容。

* 数组不够灵活。（如只能存储相同的类型等）

* 容器牺牲了一些性能

## 链表

链表是一种`线性`数据结构。但是他有特殊的底层结构：

- 链表不需要连续的内存空间，它通过指针将一组零散的内存块串联起来使用。
- 结点：指被串联的内存块，第一个结点被称为头结点，最后一个结点被称为尾结点
- 后继指针：记录下一个结点地址的指针

### 链表中数据的存储和访问

### 插入

链表的插入和删除只要改变指针的指向就可以了，复杂度为 O(1)

### 删除

因为链表不是连续内存空间存储的，所以无法通过寻址公式计算出内存位置，只能通过个个结点的遍历直到找到目标， 复杂度为 O(n)

### 特殊的链表

`循环链表`：即尾结点的后继指针指向头结点，适用于处理环形结构特点的数据。如 约瑟夫问题

`双向链表`: 即除了后继指针外，还有一个前驱指针

## 哈希

从商品的价目表说起：

    在杂货店中，有按字母顺序排列的商品价目表。

        | apple  | 1$
        | banana | 2$
        | egg    | 2$

此时我们可以比较简单查找和前面将的二分查找之间的区别：假设 1 秒可以看 10 行

        | 商品数量 | O(n)  | O(log n) |
        | 100     |  10s  |  1s      |  log 100 = 7
        | 1000    |  100s |  1s      |  log 1000 = 10
        | 10000   |  16.6m|  2s      |  log 10000 = 14 行

利用二分查找的速度已经非常快了。 但是，作为一个收银员，每次都要去查找是一个很痛苦的事情，所以我们需要的是能够记住所有商品价格，能够立马得到结果的机制。

        |  O(1) |
        |  立即  |
        |  立即  |
        |  立即  |

该如何实现呢？可以利用前面介绍的两个数据结构，实现散列表。

### 原理介绍

首先我们要有一个`散列函数`: 无论输入的是什么东西，都能得到一个数字。

- 对于相同的输入，得到的数字结果不变。
- 对于不同的输入，得到的数字结果不同（冲突的问题）

所以我们可以对所有的商品名称进行散列函数过滤得到不同的数字，将其作为下标，价格填入到数组当中去。
```
apple  =>  3
banana =>  4

a[], [], [], [3] = 1, [4] = 2
```

这样我们就得到了一个`散列表`。

`散列表`是包含额外逻辑的数据结构，通过额外的散列函数来确定元素存储的位置。特点：key => value

### 应用案例

    1、手机电话簿的号码查找
    2、去重
    3、用做缓存

### 额外扩展

#### （冲突）
散列函数的冲突问题：不同的输入得到同样的输出

简单的解决方法：在同一个位置存储一个链表

#### 填装因子

#### 良好的散列函数

### 性能分析

复杂度。